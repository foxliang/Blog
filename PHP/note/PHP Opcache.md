# PCache 介绍
OPCache 是Zend官方出品的，开放自由的 opcode 缓存扩展，还具有代码优化功能，省去了每次加载和解析 PHP 脚本的开销。

PHP 5.5.0 及后续版本中已经绑定了 OPcache 扩展。

缓存两类内容:

- OPCode

- Interned String，如注释、变量名等

## OPCache 原理
OPCache缓存的机制主要是：将编译好的操作码放入共享内存，提供给其他进程访问。

这里就涉及到内存共享机制，另外所有内存资源操作都有锁的问题，我们一一解读。

#### 共享内存
UNIX/Linux 系统提供很多种进程间内存共享的方式：

System-V shm API: System V共享内存,

sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；

mmap API：

mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上

内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种

mmap的一大优点是把文件映射到进程的地址空间

避免了数据从用户缓冲区到内核page cache缓冲区的复制过程；

当然还有一个优点就是不需要频繁的read/write系统调用


POSIX API： System V 的共享内存是过时的, POSIX共享内存提供了使用更简单、设计更合理的API.

Unix socket API

OPCache 使用了前三个共享内存机制，根据配置或者默认mmap 内存共享模式。

依据PHP字节码缓存的场景，OPCache的内存管理设计非常简单，快速读写，不释放内存，过期数据置为Wasted。

当Wasted内存大于设定值时，自动重启OPCache机制，清空并重新生成缓存。

#### 互斥锁

任何内存资源的操作，都涉及到锁的机制。

共享内存：一个单位时间内，只允许一个进程执行写操作，允许多个进程执行读操作；

写操作同时，不阻止读操作，以至于很少有锁死的情况。

这就引发另外一个问题：新代码、大流量场景，进程排队执行缓存opcode操作；重复写入，导致资源浪费。

### OPCache 缓存解读
OPCache 是官方的Opcode 缓存解决方案，在PHP5.5版本之后，已经打包到PHP源码中一起发布。

它将PHP编译产生的字节码以及数据缓存到共享内存中, 在每次请求，从缓存中直接读取编译后的opcode，进行执行。

通过节省脚本的编译过程，提高PHP的运行效率。

如果正在使用APC扩展，做同样的工作，现在强烈推荐OPCache来代替，尤其是PHP7中。

### OPCode 缓存
Opcache 会缓存OPCode以及如下内容：

- PHP脚本涉及到的函数

- PHP脚本中定义的Class

- PHP脚本文件路径

- PHP脚本OPArray

- PHP脚本自身结构/内容
