## 1、整型
有符号整数类型：int8、int16、int32和int64

无符号整数类型：uint8、uint16、uint32和uint64

跟CPU平台相关的数据类型：有符号整数int和无符号整数uint

特殊的无符号整数类型：uintptr（同指针），在32位平台下4字节，在64位平台下8字节

1.1 类型表示

int、uint和uintptr是不同类型的兄弟类型，int和int32也不是相同的类型，编译器不会帮你自动做类型转换，需要强制类型转换。比如：

```
var apples int32 = 1

var oranges int16 = 2

var compote int = apples + oranges  //compile error
```

当编译时，会产生一个错误信息：

```
invalid operation: apples + oranges (mismatched types int32 and int16)
```

解决方法是将他们都显式转型为一个常见类型：

```
var compote = int(apples) + int(oranges)
```

1.2 比较运算 

两个不同类型的整数型不能直接比较，但各种类型的整型变量都可以直接与字面常量进行比较。

```
var i int32
var j int64

i, j = 1, 2

if i == j {　　//编译错误
   fmt.Println("i and j are equal.")       
}

if i == 1 || j == 2 {　　//编译通过
   fmt.Println("i and j are equal.")    
}
```

## 2、浮点数
Go语言提供了两种精度的浮点数，float32 和 float64。它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。

如何判断两个浮点数是否相等？浮点数不是一种精确地表达方式，所以像整型那样直接用 == 来判断两个浮点数是否相等是不可行的。应该采用下面的方法：

```
package main

import (
    "fmt"
    "math"
)
const MIN = 0.000001
// MIN 为用户自定义的比较精度
func IsEqual(f1, f2 float64) bool {
    return math.Dim(f1, f2) < MIN
}

func main() {
    a := 0.0000123
    b := 0.000012234
    if IsEqual(a, b) {
        fmt.Println("a < b")
    }
}
```

## 3、布尔类型
一个布尔类型的值只有两种：true 和 false。if 和 for 语句的条件部分都是布尔类型的值，并且 == 和 < 等比较操作也会产生布尔型的值。

布尔值可以和&&（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：

```
s != "" && s[0] == 'x'
```
其中s[0]操作如果应用于空字符串将会导致panic异常。

Go语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。
## 4、常量
常量表达式值在编译时期计算，而不是在运行时期。

所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。
#### 4.1 const关键字

Go语言中的常量使用关键字 const 定义，用于存储不会改变的数据。常量是在编译时被创建，即使被定义为函数局部的也如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。

常量的定义格式和变量的声明语法类似：const identifier [type] = value，例如：
const pi = 3.14159 // 相当于 math.Pi 的近似值

在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。

显式类型定义： const b string = "abc"
隐式类型定义： const b = "abc"

#### 4.2 iota常量生成器
常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。

下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。


```
type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

## 5、字符串
Go 支持以下 2 种形式的字面值：
#### 1) 解释字符串：
该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：

\n：换行符

\r：回车符

\t：tab 键

\u 或 \U：Unicode 字符

\\：反斜杠自身

#### 2) 非解释字符串：
该类字符串使用反引号“`”括起来，支持换行，例如：

```
`This is a raw string \n` 中的 `\n\` 会被原样输出。

```

```
字符串连接：x + y；

"Hello" + "123"，结果为"Hello123"

字符串长度：len(s)

```
