#### 说到线程，首先来说下进程，

以下是进程的定义：进程是操作系统结构的基础，是程序的一次执行，是一个程序及其数据结构在处理机上顺序执行时所发生的活动，是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

简单来说一个任务管理器中列表的一个exe文件就可以理解成进程，如QQ.exe就是一个进程，进程是受系统管理的基本运行单元。

## 1.1 什么是线程？

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

简单来说，线程可以理解成为在进程中独立运行的子任务。比如，QQ.exe运行中就有很多的子任务在同时运行。

### 1.2 进程和线程的区别

1.2.1 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。

1.2.2 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。

1.2.3 拥有资源：进程是拥有资源的一个独立单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可以与同属一个进程的其他线程共享进程所拥有的全部资源。进程之间是不能共享地址空间的,而线程是共享着所在进程的地址空间的。
 
 1.2.4 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
 
 ### 1.3  什么是多线程？
 
 多线程就是几乎同时执行多个线程。
 
### 1.4 为什么要使用多线程
 
 1.4.1 使用线程可以把占据时间长的程序中的任务放到后台去处理。
 
 1.4.2 用户界面更加吸引人,这样比如用户点击了一个按钮去触发某件事件的处理,可以弹出一个进度条来显示处理的进度。
 
 1.4.3 程序的运行效率可能会提高。
 
 1.4.4 在一些等待的任务实现上如用户输入,文件读取和网络收发数据等,线程就比较有用了。
 
## 2 线程的状态
 
 一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、timed_waiting、waiting、消亡（dead）。

![images](https://github.com/foxliang/Blog/blob/master/images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

## 3 多线程的使用方式

### 3.1 继承 Thread类可以看到程序在交替执行，但是最终都会执行到98。

### 3.2 实现Runnable接口依旧可以看到程序在交替执行，但是最终都会执行到98。

### 3.3 继承实现Callable接口这里需要说明的是实现Callable接口，必须重写call()方法，并且要用到FutureTask类，这里先不做介绍，等后面更新线程池再细讲。

### 3.4 使用线程池例如用Executor框架

## 4 使用多线程一定快吗？

答：不一定，因为多线程会进行上下文切换，上下文切换会带来开销。

### 4.1 什么是上下文切换？

对于单核 CPU，CPU 在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）
。线程上下文切换过程中会记录 程序计数器、CPU  寄存器 的 状态等数据。

### 4.2 如何减少上下文切换？

4.2.1 减少线程的数量由于一个CPU每个时刻只能执行一条线程，而傲娇的我们又想让程序并发执行，操作系统只好不断地进行上下文切换来使我们从感官上觉得程序是并发执的行。

因此，我们只要减少线程的数量，就能减少上下文切换的次数。然而如果线程数量已经少于CPU核数，每个CPU执行一条线程，照理来说CPU不需要进行上下文切换了，但事实并非如此。

4.2.2 控制同一把锁上的线程数量如果多条线程共用同一把锁，那么当一条线程获得锁后，其他线程就会被阻塞；当该线程释放锁后，操作系统会从被阻塞的线程中选一条执行，从而又会出现上下文切换。因此，减少同一把锁上的线程数量也能减少上下文切换的次数。

4.2.3 采用无锁并发编程需要并发执行的任务是无状态的：HASH分段所谓无状态是指并发执行的任务没有共享变量，他们都独立执行。对于这种类型的任务可以按照ID进行HASH分段，每段用一条线程去执行。需要并发执行的任务是有状态的：CAS算法如果任务需要修改共享变量，那么必须要控制线程的执行顺序，否则会出现安全性问题。你可以给任务加锁，保证任务的原子性与可见性，但这会引起阻塞，从而发生上下文切换；为了避免上下文切换，你可以使用CAS算法，
 仅在线程内部需要更新共享变量时使用CAS算法来更新，这种方式不会阻塞线程，并保证更新过程的安全性。
 
 ## 5 使用多线程的缺点：
 
 ### 5.1 上下文切换的开销当CPU 从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”。
 
 CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。
 
 上下文切换并不廉价。
 
 如果没有必要，应该减少上下文切换的发生。
 
###  5.2 增加资源消耗线程在运行的时候需要从计算机里面得到一些资源。
 
 除了 CPU，线程还需要一些 内存来维持它本地的堆栈。它也需要 占用操作系统中一些资源来管理线程。
 
 ### 5.3 编程更复杂在多线程访问共享数据的时候，要考虑 线程安全问题 。
 
 ## 6 线程安全
 
 ### 6.1 线程安全定义一个类在可以被多个线程安全调用时就是线程安全的。
 
 ### 6.2 线程安全分类线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
 
 6.2.1. 不可变不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，只要一个不可变的对象被正确地构建出来，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。
 
 不可变的类型：final 关键字修饰的基本数据类型；String ；枚举类型；Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。
 
 但同为 Number 的子类型的原子类 AtomicInteger 和 AtomicLong 则并非不可变的。6.2.2 绝对线程安全不管运行时环境如何，调用者都不需要任何额外的同步措施。
 
 6.2.3 相对线程安全相对的线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。
 
 6.2.4 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable相对应的集合类 ArrayList 和 HashMap等。
 
 6.2.5 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。



