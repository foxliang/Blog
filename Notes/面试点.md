
1.rabbitmq kafka区别

RabbitMQ是由内在高并发的erlanng语言开发，用在实时的对可靠性要求比较高的消息传递上。

kafka是采用Scala语言开发，它主要用于处理活跃的流式数据,大数据量的数据处理上

(2)、Brokerr与Consume交互方式不同

RabbitMQ 采用push的方式

kafka采用pull的方式

(3)、在集群负载均衡方面，

rabbitMQ的负载均衡需要单独的loadbalancer进行支持。

kafka采用zookeeper对集群中的broker、consumer进行管理

(4)、使用场景

rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作；基于存储的可靠性的要求存储可以采用内存或者硬盘。

金融场景中经常使用

kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度（与分区上的存储大小无关），消息处理的效率很高。（大数据）


2.高并发 处理 

(1)、系统拆分，将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，这样就可以抗高并发。

(2)、缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考的虑考虑你的项目里，那些承载主要请求读场景，怎么用缓存来抗高并发。

(3)、MQ(消息队列)，必须得用MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，人家是缓存你要是用redis来承载写那肯定不行，数据随时就被LRU(淘汰掉最不经常使用的)了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的。

(4)、分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。

(5)、读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。

(6)、分布式 因为搭建了集群，因此具备高可用的特性，同时对数据进行主从备份，避免了单点故障问题。可以做到数据的快速恢复。并且可以动态的添加新的节点，再对数据进行平衡,可以做到负载均衡：

分布式之后考虑 幂等

3.git rebase和git merge的区别
前言：

   平时工作中发现一般同事在同步远程代码的时候都是用git pull,其实git pull包含有两个操作，一个是fetch远程的代码，一个是将本地当前的代码和远程代码进行merge，即git fetch + git merge.
其实git pull还有一个参数可以加，即git pull -rebase,其最终效果和git pull一样，也会fetch到远程代码。
即git pull默认使用的是merge模式，那么git pull -rebase指定使用rebase模式。
那么git merge和git rebase的区别是什么呢？
 
1、结果上没有区别
简单来说，git merge和git rebase从最终效果来看没有任何区别，都是将不同分支的代码融合在一起。
 
2、生成的代码树不同
虽然从最终效果上来说相同，但是git merge和git rebase生成的代码树稍微有些不同。
 
3. git merge会生成一个新的合并点，而git rebase不会。
比如：当前存在两个分支，master和test分支
     D---E test
     /
A---B---C---F master
如果使用merge合并，将为分支合并自动识别出最佳的同源合并点：并新增合并点G
  D--------E
     /         \
A---B---C---F----G  test, master

如果使用rebase合并，则合并结果为：
A---B---D---E---C'---F'   test, master 
即git rebase可以线性的看到每次提交，而git merge可以更加精确的看到每次提交。
所以想要更好的提交树，使用rebase操作会更好一点。这样可以线性的看到每一次提交，并且没有增加提交节点。
 
4. 遇到冲突时的处理
     merge 操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以继续往下操作，
而rebase 操作的话，会中断rebase，同时会提示去解决冲突。解决冲突(vi 或则其他工具)后, 将修改add后执行git rebase —continue 继续操作（会要求写入comment），或者git rebase —skip忽略冲突，之后push到远端。

