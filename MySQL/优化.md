## 一.SQL语句优化 

1.避免select *，将需要查找的字段列出来 

2.使用limit对查询结果的记录进行限定

3.使用连接（join）来代替子查询

4.拆分大的delete或insert语句

5.不做列运算：SELECT id WHERE age + 1 = 10

6.任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边

7.大语句拆小语句，减少锁时间

8.一条大sql可以堵死整个库 OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内

9.尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描 

10.对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5

11.很多时候用 exists 代替 in 是一个好的选择 

## 二.索引优化 

 1.选择合适的数据类型
 
 （1）使用可存下数据的最小的数据类型，整型 < date,time < char,varchar < blob
 
 （2）使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数
 
 （3）使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar
 
 （4）尽可能使用not null定义字段
 
 （5）尽量少用text，非用不可最好分表 
 
 2.选择合适的索引列
 
 （1）查询频繁的列，在where，group by，order by，on从句中出现的列
 
 （2）where条件中<，<=，=，>，>=，between，in，以及like 字符串+通配符（%）出现的列
 
 （3）长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好
 
 （4）离散度大（不同的值多）的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count越大，离散程度越高： 

## 三.数据库结构优化 

1.范式优化： 比如消除冗余（节省空间。。） 

2.反范式优化：比如适当加冗余等（减少join）

3.拆分表： 

分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。

这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，

一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。 

4.拆分其实又分垂直拆分和水平拆分： 案例： 简单购物系统暂设涉及如下表：

1.产品表（数据量10w，稳定） 

2.订单表（数据量200w，且有增长趋势）

3.用户表 （数据量100w，且有增长趋势）

以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万 

垂直拆分：解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 

方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上 

水平拆分： 解决问题：单表中数据量增长出现的压力 
