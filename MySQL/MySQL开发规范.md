# 一、 库表设计类规范
### 1、强制类规范
1.1、库的名称必须控制在32个字符内。库名应保持简短，同时必须要有一定的辨识度，能让维护人员一眼认出。

   1.2 、库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。相同业务系统使用相同的前缀便于维护人员将DB按业务分类，更好的规划数据库的部署策略。同一模块使用的表使用统一前缀，方便将来做拆分时能更好的识别需要拆分的表。 
   
   1.3、一般分库名称命名格式是库通配名_编号，编号从0开始递增，比如wenda_001，以时间进行分库的名称格式是“库通配名_时间”，比如wenda_201901 
   
   1.4、创建数据库时必须显式指定字符集，并且字符集只能是utf8mb4。utf8mb4是utf8的超集，更重要的是，utf8mb4支持emoji表情以及冷僻汉字的存储，这些内容在utf8中会显示为乱码。
   
   1.5、表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。表名保持简短，同时必须要有一定的辨识度，能让维护人员一眼认出。
   
   1.6、创建表时必须显式指定字符集为utf8mb4。不要指定为utf8，如果遇到utf8存储不了的数据再想转成utf8mb4的话，代价会非常高。 
   
   1.7、创建表时必须显式指定表存储引擎类型，必须为InnoDB。对于OLTP业务来说，InnoDB相对于其他存储引擎的优势非常明显。即使对于日志表来说，经过Oracle这几年的深度优化，innodb也已经优于已经濒死的MyISAM存储引擎。如果从维护的角度来看，innodb和其他引擎混合部署在同一个实例里，会造成很多麻烦，最直接的影响就是，备份只能使用冷备份，而不能使用热备份。
   
1.8、建表时，每个字段都必须有comment属性，表也要有comment。字段的备注要能明确该字段的作用，而不是流于笼统，尤其是某些表示状态的字段，要显式的写出该字段所有可能的状态数值以及该数值的含义，而不是类似“总共有4个状态，分别用1，2，3，4表示”。另外，这些comment后续也要积极维护，一旦新增了新的状态值，comment里也要及时体现出来。

1.9、所有表必须有行数据的创建时间字段create_time和最后更新时间字段 update_time。这两个字段一般优于维护，比如说数据清理，归档等。update_time字段需要设置成自动更新，并建立索引。

    1.10、不允许使用 blob、text 等大字段，如确有需要，需要DBA审批。
    
尽管使用varchar，blob、text这类大字段会快速撑大单表容量，造成后续维护的困难。对于大字段的使用，建议单独将大字段放在一个表里，与主表通过某个字段做关联查询。

1.12、对于超过 100W 行的大表进行 alter table，必须经过 DBA 审核，并在业务 低峰期执行。对大表做DDL操作非常耗IO，影响业务访问数据库的响应时间。而且，很多DDL操作在进行时是要锁住表，禁止修改的，这类操作需要DBA和开发确定时间后才能执行。

1.13、主键必须为 id，类型为 int 或 bigint，且是auto_increment()。自增主键在性能上表现较好，其他业务字段如有需要，可以设置为唯一键。

1.14、表中字段如果为NOT NULL 属性的，必须定义 DEFAULT值。避免程序异常导致，插入失败。

1.15、单个分区表中的分区（包括子分区）个数不能超过 1024。对分区表的维护操作要比普通表更慢，1024这个值应视为一个上限，工作中应极力避免用到如此多的分区。

1.16、分区表上线前 RD 或者 DBA 必须指定分区表的创建、清理策略。分区表如果维护不善，清理不及时，会导致大量数据集中在一个分区表里。这样既失去了使用分区表的优势，又继承了分区表维护操作慢的劣势，得不偿失。

1.17、采用分库策略的，库的数量不能超过 1024，且必须是2的N次方。分库分表的数量必须是2的N次方，主要是从后续拆分这个方面来考虑的。

1.18、采用分表策略的，表的数量不能超过 4096，且必须是2的N次方。不管是分库的1024还是分表的4096，都是偏高的，具体应该分多少个库，多少个表需要事先和DBA沟通确定。

1.19、表中的已有的字段不能DROP，程序应该能够兼容Add column，不会因为发布有问题，需要Drop column，同时该业务表接入到数仓ADB的话，ADB不支持这种语法，会直接导致RDS到ADB的DTS同步失败。

1.20、表中的已有的字段名不允许修改，已经上线的表的字段名不允许修改，入股该业务表接入到数仓ADB的话，ADB不支持这种语法，会直接导致RDS到ADB的DTS同步失败，建表的时候对象命名应该遵循数据库建模规范。

1.21、表中已有的字段长度只增不减，线上的业务表的字段由于前期设计考虑不充分，导致INSERT的时候值被Truncate，这个时候可以增加字段长度，但是不能由于前期设计预留的长度太大，实际的插入的值得长度很小，为了不影响select性能，需要缩小字段长度（比如varchar(4000)修改为varchar(100)）这种操作不允许的。

### 2、建议类规范
2.1中间表用于保留中间结果集，名称必须以 tmp_开头。备份表用于备份或抓取源表快照，名称必须以bak_开头。中间表和备份表会定期删除，回收空间。 

2.2、 业务中选择性很少的状态 status、类型type等字段使用 tinytint 或者smallint 类型，不要使用enum和set类型。当需要新增状态，类型时，enum和set类型需要预先提交DDL语句添加类型。而tinyint类型可以很方便的加个值作为新的状态或类型。但要记得在comment里添加一下。 

2.3、业务中 IP 地址字段推荐使用 int unsigned类型。int unsigned的取值上限4294967295对应的正好是ipv4中ip的最大值255.255.255.255。从存储空间来看，int类型只要4字节，如果定义为varchar(15)的话，消耗15字节。 

2.3、主键的名称以“pk_”开头，唯一键以“uk_”或“uq_”开头，普通索引以“idx_”开头，一律使用小写格式，以字段的名称或缩写作为后缀。比如，要在first_name字段上建普通索引的话，索引名为idx_first_name，如果要在first_name和last_name上建联合索引的话，索引名为idx_first_name_last_name。 

2.4、在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。比如有联合索引idx_col_a_col_b(col_a,col_b)，单列索引idx_col_a(col_a)和idx_col_b(col_b)，那么对col_a的单条件查询，或者对col_a,col_b的两个字段的组合条件查询，都可以用到idx_col_a_col_b（col_a,col_b）这个组合索引。idx_col_a(col_a)就是我们所说的冗余索引，平时用不到，还在那里占空间。需要注意的是，单独对条件col_b进行查询用不到idx_col_a_col_b这个组合索引，需要单独建idx_col_b(col_b)来优化。 

2.5、对于 log 或 history 类型的表，随时间增长容易越来越大，因此上线前 RD或者 DBA 必须建立表数据清理或归档方案。对于log或者history类型的表，如果事先能够预估到表会非常大的话，最好提前做好分表规划。 

2.6、数据更新基于主键操作。主键的筛选度是最好的，根据主键操作是最快的。

2.7、对于频繁读取的数据，可以放入缓存，加速访问。这边说的缓存一般是指redis，而不是MySQL的query cache。DBA推荐使用redis加速热点数据的访问，但反对使用query cache。 

## 二、 DML开发规范
### 1、强制类规范
1.1、SELECT和INSERT 语句必须指定具体字段名称。禁止使用select *，因为不利于SQL的预发布，基于同样的理由，insert时也必须显式指定对哪些列进行操作。 

1.2、DML 语句必须有 where 条件，且能使用索引。这里主要指的是update和delete操作，全表更新和删除，尤其是对较大的表做这类操作时，会引起明显的从库延迟，这个延迟是实例级的，而不是表级的。对于读写分离应用，从库的高延迟会导致应用读取不到最新数据，造成异常。对于数据库高可用性来说，当主库故障时，有延迟的从库不能立即成为主库，导致应用恢复时间延长。 

1.3、生产环境禁止使用 hint，如 sql_no_cache，force index，ignore key，straight join等。当数据集变化时，当时强制指定的force_index可能已经不是最好的选择。因此，不要依赖这类技术来解决临时的SQL性能问题，而是要从SQL本身着手，通过修改SQL来使优化器走到正确的索引。 

1.4、where 条件里等号左右字段类型必须一致。如果要查询的uid字段是int型的，那么就要写成uid=123456，如果uid是varchar型的，那么就要写成uid='123456'。 

1.5、WHERE 子句中禁止只使用前缀模糊匹配的 LIKE 条件进行查找。前缀查询是指类似uid='%123456'，条件中%在最前面的查询。在这类查询中，即使uid上有索引，SQL也不会使用到。 

1.6、Where条件中不要在筛选字段上使用函数或表达式。比如将条件写成mod(uid,10)=1，这样写也用不到索引。 

1.7、禁止跨 db 的 join 语句。第一，是为了减少不同模块间的耦合性；第二，只有当两个DB在同一个实例里时，跨库join才能实现。但随着数据量和访问量的增长，DBA在后续维护中，可能会将原先部署在一起的两个DB，拆分到不同的实例中去。如果业务中存在跨库join，会影响DBA的拆分工作，最终影响业务的整体响应速度。 

1.8、禁止在业务的update语句中使用 join。建议可以先查出需要修改的数据主键值，然后根据主键更新。

1.9、禁用 procedure、function、trigger、views、event、外键约束。尤其要避免将业务逻辑封装在数据库的存储过程中。MySQL中的存储过程调试起来比较麻烦，且数据库并不善于处理复杂的逻辑运算。因此，要想数据库更快，那就直接告诉它想要的数据怎么取，而不是让它通过逻辑计算，算出结果。 

1.10、前端程序连接MySQL或者redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。时间间隔要合理不能太短，没有时间间隔或者太短的时间间隔，不仅不能快速重连，还会演变成对数据库的DDOS攻击。 

### 2、建议类规范
2.1、insert into…values(XX),(XX),(XX)这里 XX 的值不要超过 5000。尽量将操作打散，在批次间加入短暂的休眠，避免引起复制延迟等一系列副作用。

2.2、SELECT 语句不要使用 UNION，推荐使用 UNION ALL。这两者的区别是：UNION会做去重操作，速度较慢，cpu开销较大，UNION ALL不去重，速度快，开销小。 

2.3、in 值列表限制在 500 以内。如果是select的话，可以避免返回过大的数据集；如果是update，delete的话，可以更快的完成修改操作。 

2.4、事务里批量更新数据需要控制数量，进行必要的 sleep。对于任何批量操作，都应加入休眠机制。

2.5、减少使用 or 语句，可将 or 语句优化为 union all查询。将select ... where col_a=1 or col_b=2改写成select ... where col_a=1 union all select ... where col_b=2，当col_a和col_b上都有合适的索引时，将能提高查询速度。 

2.6、分页查询，当 limit 起点较高时，可先用过滤条件进行过滤。limit 20000,20并不是直接返回第20000行之后的20行，而是先扫描20000行，然后返回扫描的20001行到20020行。由此可见，偏移量越多，性能越差，如果一个表就只有21000行的话，limit 20000,20几乎就相当于全表扫描了。建议先根据where后的条件查出需要修改的数据的最小自增主键，然后就可以通过自增主键来做分页了。 

2.7、建议不要使用子查询，可以将子查询 SQL 拆开结合程序多次查询，或使用join来代替子查询。最要当心的是select ... where id in (select id ...)，能用join替代的就用join，不行的话就把子查询拆开，多次查询。 

2.8、线上环境，多表 join 不要超过 3 个表。表join过多会导致性能降低。 

2.9、一个事务里包含 SQL 不超过 5 个（支付业务除外）。事务越小，锁越小，对整个表的影响也越小。

2.10、不要把诸如调用 webservice，访问文件存储，RMQ等放在SQL事务里。当诸如RMQ或者文件存储发生故障时，会拖累数据往数据库的写入。 

2.11、减少使用 order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。尽量降低数据库服务器的CPU开销。


参考：[专业的MySQL开发规范](https://blog.ops-coffee.cn/s/zfr5kn1tejvsih-miret3a)
