# 一 发布订阅
## 1.1 任务队列
当页面需要发送如邮件、复杂数据运算等耗时操作时会阻塞页面渲染，为了避免用户等待太久，往往会开启一个独立进程来完成这类操作，在页面中只要想办法通知这个进程向指定的地址发送邮件即可。

通知的过程可以借助任务队列实现，即传递任务的队列。生产者将需要处理的任务加入任务队列，消费者不断从任务队列中读入任务并执行。

对于发邮件操作来说：页面程序就是生产者，发邮件的进程是消费者。当需要发送邮件时，页面程序会将收件地址、邮件内容等组成一个任务后存入任务队列中，同时发邮件的进程会不断检查任务队列，一旦发现有新的任务便会将其从对垒中取出并执行，由此实现了进程间的通信。

使用任务队列的好处：


- 低耦合：生产者和消费者无需知道彼此实现细节

- 易扩展：消费者可以有多个，可以分布在不同的服务器中

一般来说，发布与订阅（pub/sub）的特点是：订阅者（listener）负责订阅频道（channel），发布者（publisher）负责向频道发送二进制字符串消息。每当有消息被发送至频道时，频道的所有订阅者都会受到消息。

## 1.2 redis实现任务队列
使用Redis的列表类型，生产者使用LPUSH将任务加入某个键，消费者不断使用RPOP从该键中取出任务即可。发邮件的伪代码如下：
```
loop						    # 无线循环读取任务队列内容
$task = RPOP queue			
if $task						
execute($task)				    # 如果任务队列中有任务则执行该任务
else
wait 1 second				    # 没有任务则等待1秒后继续查询
```
上述案例并不完美，因为没有任务的时候，消费者仍然在循环读取队列数据，使用BRPOP命令，在没有元素时，可以阻塞连接，直到有新元素加入，上述伪代码可以改写为：

```
loop
$task = BRPOP queue,0
execute($task[1]);
```
BRPOP命令会接收2个参数，第一个是键名，第二个是超时时间，单位是秒，超过了超时时间，仍然没有获得新元素，则返回nil，案例中超时时间为0，即不限制等待事假，即如果没有新元素加入列表就会永远阻塞下去。当获得一个元素后，该命令分别返回键名和元素值。同理，BLPOP会从左边取出元素:

```
客户端1						客户端2 
BRPOP queque 0				LPUSH queque task
> 1
queue
task						
LLEN queue				//实例中的元素已经被取走
> 0
```
## 1.3 redis实现优先级队列

博客在发布文章的时候回向每个订阅者发送邮件，这个步骤可以使用任务队列实现，由于要执行的任务和发送确认邮件一样，所以二者可以使用同一个消费者。但是这时候就会带来问题：如果有1000个用户订阅，发布一篇文章后向1000个用户发送推送邮件，每次发送消耗10秒，那么这1000个任务要消耗近3个小时，在此期间，如果有个用户想注册账号，同样也会发送邮件，该用户需要等待3个小时才能收到邮件。。。

所以当发送确认邮件、发送通知邮件两种任务同时存在时，应该优先执行前者。

BRPOP可以同时接收多个键，完整格式为：

```
BLPOP key key key.... timeout 
ReadisA									RedisB
BLPOP queue:1 queue2 queue:3 0				LPUSH queue:2 task
> 1
queueL2
task
```
如果多个键都有元素则按照从左到右的顺序取出第一个键中的第一个元素，现在queue:2和queue:3中个加入一个元素：

```
ReadisA									RedisB
LPUSH queue:2 task1						LPUSH queue:3 task2
>1										>1
执行：

BRPOP queque:1 queue:2 queue:3 0
输出 queue:2 task1
```
## 1.4 redis实现发布订阅
除了任务队列，Redis提供了发布订阅模式，同样可以实现进程间传递消息：发布者可以订阅一个或多个频道，而发布者可以向指定频道发送消息，所有订阅此频道的订阅者都会收到消息。

发布：

```
PUBLISH channel1.1 hi
0					                    # 返回值表示接受这小消息订阅者的数量
```
发布的消息不会被持久化，客户只能收到订阅之后产生的消息。

订阅：

```
SUBSCRICE channel1.1 channel1.2...		# 可以订阅多个
```
执行订阅后，客户端处于订阅状态，此时客户端不能再使用除了发布订阅相关命令外的其他命令，否则会报错。

进入订阅的客户端可能会受到3种类型的回复，每种类型的回复都包含3个值，第一个值时消息的类型，根据消息类型的不同，第二个 三个值的含义不同。

消息类型可能是：

- 1 subscribe 表示订阅成功反馈的信息，第二个值时订阅成功的频道名称，第三个值是当前客户端订阅的数量。

- 2 message 表示接收到的消息，第二个值是产生消息的频道，第三个值是消息的内容

- 3 unsubscribe 表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时，退出订阅模式。

UNSUBSCRIBE可以取消订阅频道(支持多个)。

PSUBSCRIBE命令可以指定订阅的规则：

```
PSUBSCRIBE channel1.?*			//支持匹配到1.1  1.10 但是不会匹配 1.
```
注意：

PSUBSCRIBE可以重复订阅同1个频道，也会接收到该频道的重复消息；

使用PUNSUBSCRIBE只可以退订通过PSUBSCRIBE订阅的规则。

由于严格的字符串匹配 PUNSUBSCRIBE * 无法退订 channel.*规则，必须使用 PUNSUBSCRIBE channel.*

## 1.5 redis的任务队列缺陷

Redis基于SUBSCRIBE 和PUBLISH 命令的发布订阅并不好：

- 稳定性不足：

如果订阅者读取速度不够快，会造成消息的积压，最终导致Redis变慢，甚至影响系统整体稳定性，新版redis不会出现该问题，因为会自动断开不符合配置：client-output-buffer-limit pubsub的订阅客户端。

- 可靠性不足：

因为网络的传输并不可靠，因为断线产生的错误会使网络连接的两端中的其中一端进行重新连接。虽然客户端可以断线重连，但是如果客户端在执行订阅操作的过程中断线，那么客户端会丢失在断线期间发送的所有消息。
