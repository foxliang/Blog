# 一 基本操作
db                          查看当前数据库名称，默认数据库为test，没有创建新数据库，集合将存放在test数据库中

db.stats()                  查看当前数据库信息

show dbs                    列出所有在物理上存在的数据库

use databasename            切换数据库，如果不存在，则指向该数据库，但不创建，只有插入数据/创建集合时数据库才被创建

db.dropDatabase()           删除当前指向的数据库

# 二 集合操作
show collections            查看当前数据库下的集合

db.collectionname.drop()    删除对应集合

db.createCollection(name)   创建集合，可以添加第二个参数，参数为json格式，字段为对应集合的一些可选项，如：

                            { capped : true, size : 10 }，capped（默认false）是否设置上限，当capped值为true时，需要指定size，表示上限大小，当文档达到上限时，会将之前的数据覆盖，单位为字节
# 三 数据操作之 增删改查

## 3.1 增

向集合中插入一个文档，文档即类似json的对象结构
```
db.collectionname.insert(document)
```
当然也支持JS语法：
```
s1={_id:'20160101',name:'hr'}
s1.gender=0
db.stu.insert(s1)
```

除了insert外，save也可以用于增加：如果文档的_id已经存在则修改，如果文档的_id不存在则添加。  

而insert插入时，如果发现主键id已经存在，则不执行操作。
```
db.stu.save({_id:'20160102','name':'yk',gender:1})
```
## 3.2 删
```
db.集合名称.remove(
   <query>,
   {
     justOne: <boolean>
   }
)
```
参数query:可选，删除的文档的条件

参数justOne:可选，如果设为true或1，则只删除一条，默认false，表示删除多条

```
db.stu.remove({})    # 全部删除
```
## 3.3 改
```
db.集合名称.update(
   <query>,
   <update>,
   {multi: <boolean>}
)
```
参数query:查询条件，类似sql语句update中where部分

参数update:更新操作符，类似sql语句update中set部分

参数multi:可选，默认是false，表示只更新找到的第一条记录，值为true表示把满足条件的文档全部更新  

当然还有upsert命令也用于更新，当指定文档不存在时，默认就会插入该新文档。

全文档更新

```
db.stu.update({name:'hr'},{name:'mnc'})

```
$set更新键值，不存在该属性则会创建
```
db.stu.update({name:'hr'},{$set:{name:'hys'}})
```

$inc追加数字类型键的值，不存在该属性则会创建
```
db.user.update({"name":"zs"},{$inc:{"age":10}})
```

$push       为数组类型键的值追加元素，如果不存在该数组键，则创建

$ne         判断值是否存在于数组中，不存在则添加

$addToSet   作用同$ne，可以避免重复

$pop        从数组中第一个或者最后一个删除元素，如{$pop:{arr:-1}}表示从开头删除数组

$pull       从数组中删除指定元素

也可以按照数组索引来修改数组

```
{$set: {"arr.0":"test"}}
```
有时候我们不知道元素的索引，则可以使用$定位器：
```
update({"person_arr.name":"lisi"},{$set: {"person_arr.$.age:30}})  //将人名数组person_arr中的 lisi 的年龄改为为30
```
注意：定位操作只会更新第一个

更新完毕后使用getLastError命令可以获取上一次更新的数量
```
db.runCommand({getLastError:1})
```

更新完毕后使用findAndModiy命令可以获取上一次更新的文档本身
## 3.4 查
```
db.集合名称.find()          # 空参表示查询全部，参数为类似json的对象
```
# 四 原理
## 4.1 插入原理
MongoDB在执行插入时，执行步骤：

1- 将插入的数据转换为BSON格式

2- 解析BSON，，并检查是否存在_id键，（不存在，则插入时自动生成）

2- 检查文档代销是否超过16M（1.8版本前为4M）

3- 将BSON文档原样存入数据库 Mongo这样简单的处理的好处是不会受到注入攻击，更加安全（因为插入时不执行代码，只是原样插入），坏处是容易插入无效数据。

注意:启动Mongo时可以加入--objcheck选项，插入数据前会先检查文档结构的有效性，但是会牺牲性能

## 4.2 批量插入
批量插入能传入一个由文档组成的数组给数据库。批量插入时，一次发送的多个文档，只会产生一个TCP请求，可以明显提高速度。

注意：只能批量插入到一个集合中，不能插入到多个集合中。

## 4.3 remove()与drop()对比
db.集合名.remove()与db.集合名.drop()都可以用来删除集合，但是后者性能极高，因为前者可以额外传参，制定删除集合中的哪些数据。

## 4.4 update的速度对比

$inc只是更新键值，速度非常快，

$set适用于文档大小发生改变时使用，也不会影响性能。

MongoDB预留了一些补白给文档，以适应带下变化，如果超出原来的空间，就得重新分配一块新的空间。

空间分配速度会减慢，同时也会随着数组变长，这时就需要更长的时间来遍历数组，对于每个数组的修改速度会减慢。

推荐使用$push，但是如果push也成为了瓶颈，则推荐将该数组抽离，组成一个新的集合。

## 五 连接池

数据库会没每个Mongo连接创建一个队列，存放这个连接的请求。当客户端发送一个请求，会放到队列的队尾，依次执行。

注意：每个连接都有独立的队列，如果打开两个shell，就会有两个数据库的连接，在一个shell中执行插入，在另外一个shell是不一定能查询到的，有一定的时间间隔。 当使用一致的连接字符串时（连接字符串一样，否则会新建一个池），这些连接会放在一个池中重复利用。如果要重复利用这些连接必须设置连接池的最小值MinimumPoolSize，否则连接池会在一定时间内关闭这些连接。当设置了最小值时，连接池会保留这个数值的活动连接以重复利用，可以避免反复创建而浪费开销。
也并不能说有连接池就能提升效率，当池的上限MaximumPoolSize设置不合理时，会导致这些连接都被占用。如果需要在创建新的连接时，就需要等待了。此外还要合理设置连接等待、连接超时，可以防止一个连接占用时间太长，影响到其他连接。 Mongo官方推荐每个客户端对服务器的连接不能超过100个，即一台计算机开启多个相同或不同的应用分别可以并行100个连接。

示例：一台PC有10个应用，100台PC去连接数据库，此时max的值为：10100100
